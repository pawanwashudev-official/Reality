function doPost(e) {
    // Action "run_nightly" requires password param
    if (e.parameter.action === 'run_nightly') {
        const password = e.parameter.password;
        let force = false;

        if (password === 'Run') {
            force = false;
        } else if (password === 'ADVANCE_RUN') {
            force = true;
        } else {
            return ContentService.createTextOutput(JSON.stringify({
                status: "error", error: "Invalid Password"
            })).setMimeType(ContentService.MimeType.JSON);
        }

        const result = pawanwashudev(force);
        return ContentService.createTextOutput(JSON.stringify(result)).setMimeType(ContentService.MimeType.JSON);
    }
}

function pawanwashudev(force = false) {
    const now = new Date();
    const hour = now.getHours();
    const minutes = now.getMinutes();

    // 1. CHECKS: Run if time matches OR if forced.
    // Allowed window is 11:00 PM to 11:59 PM
    if (force === true || (hour === 23)) {

        try {
            // 2. DUPLICATION CHECK
            // Open the Sheet and check the Last Row Key
            const ss = SpreadsheetApp.openById("185LMWyfq-qSfwvRZANYT2Z-aWTyrzKyYFsgYl7mQxLI");
            const sheet = ss.getSheetByName("Form Responses 1");

            if (sheet) {
                const lastRow = sheet.getLastRow();
                if (lastRow > 1) {
                    const lastDateVal = sheet.getRange(lastRow, 1).getValue(); // Column A: Timestamp
                    const lastDate = new Date(lastDateVal);

                    // Compare Date Strings (YYYY-MM-DD)
                    const t1 = Utilities.formatDate(now, Session.getScriptTimeZone(), "yyyy-MM-dd");
                    const t2 = Utilities.formatDate(lastDate, Session.getScriptTimeZone(), "yyyy-MM-dd");

                    // If today matches the last entry date, WE ALREADY RAN TODAY.
                    // If force=true, we SKIP this check and run again.
                    // If force=false, we STOP here.
                    if (t1 === t2 && !force) {
                        Logger.log("âš ï¸ Skipped: Nightly Routine already ran for today (" + t1 + ")");
                        return { status: "skipped", reason: "Already ran today" };
                    }
                }
            }

            Logger.log("ðŸš€ Starting Nightly Protocol...");

            // Step 1â€“5
            copySequentialTimelogToFormResponses();
            updateTaskStatsSimple();
            processReflectionAndFillColumns();
            processStudyPlanWithGroq();
            nfcalculation();

            Utilities.sleep(10000);
            fillGeminiColumns();

            // Step 7â€“11
            createSimpleNextDayDoc();
            generateTodayFeedbackPDF();
            createEventsFromPlan();
            sendSummaryEmail();
            syncFromSheetTrigger();

            Logger.log("âœ… All functions executed successfully.");
            return { status: "success" };

        } catch (err) {
            Logger.log("âŒ Error during execution: " + err);
            return { status: "error", error: err.toString() };
        }

    } else {
        Logger.log(`â±ï¸ Skipped: Not 11 PM window. Now = ${hour}:${minutes}`);
        return { status: "skipped", reason: "Time mismatch (Window: 11:00 PM - 11:59 PM)" };
    }
}


function copySequentialTimelogToFormResponses() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const timelogSheet = ss.getSheetByName('Timelog');
  const responseSheet = ss.getSheetByName('Form Responses 1');
  const tz = Session.getScriptTimeZone();

  // Step 1: Get last date from Form Responses 1
  const responseData = responseSheet.getDataRange().getValues();
  const lastResponseRow = responseData.length - 1;

  let lastLoggedDate;
  if (lastResponseRow >= 1) {
    const rawTimestamp = responseData[lastResponseRow][0];
    lastLoggedDate = new Date(rawTimestamp);
  } else {
    // If no data, start from today minus one day
    lastLoggedDate = new Date();
    lastLoggedDate.setDate(lastLoggedDate.getDate() - 1);
  }

  // Step 2: Increment by one day (date part)
  const nextDate = new Date(lastLoggedDate);
  nextDate.setDate(nextDate.getDate() + 1);

  // Step 3: Merge with current time
  const now = new Date();
  nextDate.setHours(now.getHours());
  nextDate.setMinutes(now.getMinutes());
  nextDate.setSeconds(now.getSeconds());

  const formattedTimestamp = Utilities.formatDate(nextDate, tz, 'M/d/yyyy H:mm:ss');

  // Step 4: Check if Timelog already has this date
  const nextDateOnlyStr = Utilities.formatDate(nextDate, tz, 'yyyy-MM-dd');
  const timelogData = timelogSheet.getDataRange().getValues();
  const existingEntry = timelogData.find(row => {
    const rowDate = Utilities.formatDate(new Date(row[0]), tz, 'yyyy-MM-dd');
    return rowDate === nextDateOnlyStr;
  });

  let valueToCopy;
  if (existingEntry) {
    valueToCopy = existingEntry[1];
  } else {
    // Append default entry to Timelog
    timelogSheet.appendRow([nextDateOnlyStr, '0+0+0']);
    valueToCopy = '0+0+0';
  }

  // Step 5: Append to Form Responses 1
  responseSheet.appendRow([formattedTimestamp, valueToCopy]);

  Logger.log(`Logged "${valueToCopy}" for ${formattedTimestamp} into Form Responses 1`);
}