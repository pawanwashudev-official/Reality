function createEventsFromPlan() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Form Responses 1");
  const lastRow = sheet.getLastRow();

  // Get values
  const dateStr = sheet.getRange(lastRow, 1).getValue(); // Column A
  const userText = sheet.getRange(lastRow, 11).getValue(); // Column K

  // Parse date and add +1 day
  const baseDate = new Date(dateStr);
  const eventDate = new Date(baseDate.getTime() + 24 * 60 * 60 * 1000);

  // Call API with Fallback logic
  const aiResponse = getAiResponseWithFallback(userText);

  if (!aiResponse) {
    Logger.log("Both AI models failed, no events created");
    return;
  }

  try {
    // Clean possible code fences
    const clean = aiResponse.replace(/```json|```/g, "").trim();
    const parsed = JSON.parse(clean);

    if (!parsed.events || !Array.isArray(parsed.events)) {
      Logger.log("No events array found in AI response");
      return;
    }

    parsed.events.forEach(ev => {
      const eventName = ev.eventName || "Untitled Event";
      const startTime = ev.startTime || "10:00";
      const endTime   = ev.endTime   || "11:00";

      const [startHour, startMin] = parseTime(startTime);
      const [endHour, endMin]     = parseTime(endTime);

      const startDateTime = new Date(eventDate);
      startDateTime.setHours(startHour, startMin, 0, 0);

      const endDateTime = new Date(eventDate);
      endDateTime.setHours(endHour, endMin, 0, 0);

      CalendarApp.getDefaultCalendar().createEvent(eventName, startDateTime, endDateTime);
      Logger.log("Event created: " + eventName + " " + startTime + "-" + endTime);
    });

  } catch (e) {
    Logger.log("Error parsing AI response: " + e);
  }
}

/**
 * Tries Perplexity first, then falls back to Groq (OSS 70B/120B class)
 */
function getAiResponseWithFallback(userText) {
  const scriptProps = PropertiesService.getScriptProperties();
  const perplexityKey = scriptProps.getProperty("PERPLEXITY_API_KEYP");
  const groqKey = scriptProps.getProperty("GROQ_API_KEY");

  const prompt = `
Extract ALL Study sessions from the following plan, Choose only study plan.
Return ONLY valid JSON in this exact format, no extra text:

{
  "events": [
    { "eventName": "Brisk walk", "startTime": "06:30", "endTime": "07:00" },
    { "eventName": "Get ready / errands", "startTime": "07:15", "endTime": "07:50" },
    ...
  ]
}

Input:
${userText}
`;

  // --- 1. Try Perplexity ---
  try {
    Logger.log("Attempting Perplexity...");
    const pResponse = callApi(
      "https://api.perplexity.ai/chat/completions",
      perplexityKey,
      "sonar-pro",
      prompt
    );
    if (pResponse) return pResponse;
  } catch (e) {
    Logger.log("Perplexity failed: " + e);
  }

  // --- 2. Fallback to Groq (OSS Model) ---
  try {
    Logger.log("Attempting Groq Fallback...");
    const gResponse = callApi(
      "https://api.groq.com/openai/v1/chat/completions",
      groqKey,
      "llama-3.3-70b-versatile",
      prompt,
      true // Enable JSON mode for Groq
    );
    if (gResponse) return gResponse;
  } catch (e) {
    Logger.log("Groq fallback failed: " + e);
  }

  return null;
}

/**
 * Generic API Caller
 */
function callApi(url, apiKey, model, prompt, isGroq = false) {
  const payload = {
    model: model,
    messages: [
      { role: "system", content: "You return only valid JSON." },
      { role: "user", content: prompt }
    ],
    temperature: 0
  };

  if (isGroq) {
    payload["response_format"] = { "type": "json_object" };
  }

  const options = {
    method: "post",
    headers: {
      "Authorization": "Bearer " + apiKey,
      "Content-Type": "application/json"
    },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };

  const response = UrlFetchApp.fetch(url, options);
  const resCode = response.getResponseCode();
  const resText = response.getContentText();

  if (resCode === 200) {
    const data = JSON.parse(resText);
    return data.choices[0].message.content.trim();
  } else {
    throw new Error("API Error " + resCode + ": " + resText);
  }
}

function parseTime(t) {
  t = t.trim().toUpperCase();
  if (t.includes("AM") || t.includes("PM")) {
    const d = new Date("1970/01/01 " + t);
    return [d.getHours(), d.getMinutes()];
  }
  const [h, m] = t.split(":").map(Number);
  return [h, m || 0];
}